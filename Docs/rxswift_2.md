## RxSwift(part2)

[RxSwift GitHub](https://github.com/ReactiveX/RxSwift)

### RxCocoa APIS

* NSObject

> Observe

```

func showArticle() -> Observable<Bool> {
        return articleModel.rx.observe(Int.self, "type").map { optionalType -> Bool in
            guard let type = optionalType else {
                return false
            }
            return type == 0 ? true : false
        }
    }

```

<!--more-->

* UIActivityIndicatorView

```

	/// Bindable sink for `startAnimating()`, `stopAnimating()` methods.
    public var isAnimating: UIBindingObserver<Base, Bool>

```
* UIAlertAction

```
	/// Bindable sink for `enabled` property.
	public var isEnabled: UIBindingObserver<Base, Bool>

```

* UIApplication

```
	/// Bindable sink for `networkActivityIndicatorVisible`.
	public var isNetworkActivityIndicatorVisible: UIBindingObserver<Base, Bool>

```

* UIBarButtonItem

```

/// Bindable sink for `enabled` property.
    public var isEnabled: UIBindingObserver<Base, Bool>
    
/// Bindable sink for `title` property.
    public var title: UIBindingObserver<Base, String>

/// Reactive wrapper for target action pattern on `self`.
    public var tap: ControlEvent<Void> 
```

* UIButton

```
/// Reactive wrapper for `TouchUpInside` control event.
    public var tap: ControlEvent<Void>

```

* UICollectionView

```

public func items<S: Sequence, O: ObservableType>
        (_ source: O)
        -> (_ cellFactory: @escaping (UICollectionView, Int, S.Iterator.Element) -> UICollectionViewCell)
        -> Disposable where O.E == S
 
 public func setDataSource(_ dataSource: UICollectionViewDataSource)
        -> Disposable
 
 public var itemSelected: ControlEvent<IndexPath> 
 
 public var itemDeselected: ControlEvent<IndexPath> 
 
 public func modelSelected<T>(_ modelType: T.Type) -> ControlEvent<T>
 
 public func modelDeselected<T>(_ modelType: T.Type) -> ControlEvent<T>
 
 public func model<T>(at indexPath: IndexPath) throws -> T 
 

```

* UIControl

```
/// Bindable sink for `enabled` property.
    public var isEnabled: UIBindingObserver<Base, Bool>
    
    /// Bindable sink for `selected` property.
    public var isSelected: UIBindingObserver<Base, Bool>
    
    /// Reactive wrapper for target action pattern.
    ///
    /// - parameter controlEvents: Filter for observed event types.
    public func controlEvent(_ controlEvents: UIControlEvents) -> ControlEvent<Void>
    

```

* UIDatePicker

```
/// Reactive wrapper for `date` property.
    public var date: ControlProperty<Date>
    
    /// Reactive wrapper for `date` property.
    public var value: ControlProperty<Date> 

```

* UIGestureRecognizer

```
/// Reactive wrapper for gesture recognizer events.
    public var event: ControlEvent<Base>
    
```

* UIImageView

```
/// Bindable sink for `image` property.
public var image: UIBindingObserver<Base, UIImage?>

```

* UILabel

```
/// Bindable sink for `text` property.
    public var text: UIBindingObserver<Base, String?>
    
/// Bindable sink for `attributedText` property.
	public var attributedText: UIBindingObserver<Base, NSAttributedString?>

```

* UINavigationController

```
/// Reactive wrapper for delegate method `navigationController(:willShow:animated:)`.
    public var willShow: ControlEvent<ShowEvent>
    
/// Reactive wrapper for delegate method `navigationController(:didShow:animated:)`.
    public var didShow: ControlEvent<ShowEvent> 

```

* UINavigationItem

```
/// Bindable sink for `title` property.
    public var title: UIBindingObserver<Base, String?>

```

### RxCocoa Highlighted API


* bind

```

/**
    Creates new subscription and sends elements to observer.
    
    In this form it's equivalent to `subscribe` method, but it communicates intent better, and enables
    writing more consistent binding code.
    
    - parameter to: Observer that receives events.
    - returns: Disposable object that can be used to unsubscribe the observer.
    */
    public func bind<O: ObserverType>(to observer: O) -> Disposable where O.E == E {
        return self.subscribe(observer)
    }

```

example 1

```

 example("PublishSubject"){
            
            // PublishSubject
            
            let subject = PublishSubject<String>()
            let bindSubject = PublishSubject<String>()
            
            subject.addObserver("2").disposed(by: disposeBag)
            
            subject.bind(to: bindSubject).addDisposableTo(disposeBag)
            
            bindSubject.subscribe(onNext: { (str) in
                print("bind----\(str)")
            }).addDisposableTo(disposeBag)
            
            subject.onNext("üÖ±Ô∏è")
            
        }
        
--- PublishSubject example ---

Subscription: 2 Event: next(üÖ±Ô∏è)
bind----üÖ±Ô∏è

```

example 2

```
cameraButton.rx.tap
            .flatMapLatest { [weak self] _ in
                return UIImagePickerController.rx.createWithParent(self) { picker in
                    picker.sourceType = .camera
                    picker.allowsEditing = false
                }
                .flatMap { $0.rx.didFinishPickingMediaWithInfo }
                .take(1)
            }
            .map { info in
                return info[UIImagePickerControllerOriginalImage] as? UIImage
            }
            .bind(to: imageView.rx.image)
            .disposed(by: disposeBag)

```

* UIBindingObserver

> RxCocoa UIÁªÑ‰ª∂ÂÄºÁªëÂÆöÊ†∏ÂøÉ

```

/**
Observer that enforces interface binding rules:
 * can't bind errors (in debug builds binding of errors causes `fatalError` in release builds errors are being logged)
 * ensures binding is performed on main thread
 
`UIBindingObserver` doesn't retain target interface and in case owned interface element is released, element isn't bound.
 
 In case event binding is attempted from non main dispatch queue, event binding will be dispatched async to main dispatch
 queue.
*/

public final class UIBindingObserver<UIElementType, Value> : ObserverType where UIElementType: AnyObject {
    public typealias E = Value

    weak var UIElement: UIElementType?

    let binding: (UIElementType, Value) -> Void

    /// Initializes `ViewBindingObserver` using
    public init(UIElement: UIElementType, binding: @escaping (UIElementType, Value) -> Void) {
        self.UIElement = UIElement
        self.binding = binding
    }

    /// Binds next element to owner view as described in `binding`.
    public func on(_ event: Event<Value>) {
        if !DispatchQueue.isMain {
            DispatchQueue.main.async {
                self.on(event)
            }
            return
        }

        switch event {
        case .next(let element):
            if let view = self.UIElement {
                binding(view, element)
            }
        case .error(let error):
            bindingErrorToInterface(error)
        case .completed:
            break
        }
    }

    /// Erases type of observer.
    ///
    /// - returns: type erased observer.
    public func asObserver() -> AnyObserver<Value> {
        return AnyObserver(eventHandler: on)
    }
}

```


```
UIControl+Rx

/// Bindable sink for `enabled` property.
    public var isEnabled: UIBindingObserver<Base, Bool> {
        return UIBindingObserver(UIElement: self.base) { (owner, value) in
            owner.isEnabled = value
        }
    }

```

example

```

let control = UIControl(frame: CGRect(x: 0, y: 0, width: 1, height: 1))
        
          _ = Observable.just(true).bind(to: control.rx.isEnabled)

```

* ControlEvent

> RxCocoa UIÁªÑ‰ª∂ÁÇπÂáª‰∫ã‰ª∂ÁªëÂÆöÊ†∏ÂøÉ

> Á±ªÂÆö‰πâ

```

/// Protocol that enables extension of `ControlEvent`.
public protocol ControlEventType : ObservableType {

    /// - returns: `ControlEvent` interface
    func asControlEvent() -> ControlEvent<E>
}

/**
    Trait for `Observable`/`ObservableType` that represents event on UI element.

    It's properties are:

    - it never fails
    - it won't send any initial value on subscription
    - it will `Complete` sequence on control being deallocated
    - it never errors out
    - it delivers events on `MainScheduler.instance`

    **The implementation of `ControlEvent` will ensure that sequence of events is being subscribed on main scheduler
     (`subscribeOn(ConcurrentMainScheduler.instance)` behavior).**

    **It is implementor's responsibility to make sure that that all other properties enumerated above are satisfied.**

    **If they aren't, then using this trait communicates wrong properties and could potentially break someone's code.**

    **In case `events` observable sequence that is being passed into initializer doesn't satisfy all enumerated
     properties, please don't use this unit.**
*/
public struct ControlEvent<PropertyType> : ControlEventType {
    public typealias E = PropertyType

    let _events: Observable<PropertyType>

    /// Initializes control event with a observable sequence that represents events.
    ///
    /// - parameter events: Observable sequence that represents events.
    /// - returns: Control event created with a observable sequence of events.
    public init<Ev: ObservableType>(events: Ev) where Ev.E == E {
        _events = events.subscribeOn(ConcurrentMainScheduler.instance)
    }

    /// Subscribes an observer to control events.
    ///
    /// - parameter observer: Observer to subscribe to events.
    /// - returns: Disposable object that can be used to unsubscribe the observer from receiving control events.
    public func subscribe<O : ObserverType>(_ observer: O) -> Disposable where O.E == E {
        return _events.subscribe(observer)
    }

    /// - returns: `Observable` interface.
    public func asObservable() -> Observable<E> {
        return _events
    }

    /// - returns: `ControlEvent` interface.
    public func asControlEvent() -> ControlEvent<E> {
        return self
    }
}

```

> Â∞ÅË£Ö

```
/// Reactive wrapper for target action pattern.
    ///
    /// - parameter controlEvents: Filter for observed event types.
    public func controlEvent(_ controlEvents: UIControlEvents) -> ControlEvent<Void> {
        let source: Observable<Void> = Observable.create { [weak control = self.base] observer in
            MainScheduler.ensureExecutingOnScheduler()

            guard let control = control else {
                observer.on(.completed)
                return Disposables.create()
            }

            let controlTarget = ControlTarget(control: control, controlEvents: controlEvents) {
                control in
                observer.on(.next())
            }
            
            return Disposables.create(with: controlTarget.dispose)
        }.takeUntil(deallocated)

        return ControlEvent(events: source)
    }

```

> ‰ΩøÁî®

```
extension Reactive where Base: UIButton {
    
    /// Reactive wrapper for `TouchUpInside` control event.
    public var tap: ControlEvent<Void> {
        return controlEvent(.touchUpInside)
    }
}

```


* Driver

> Áî®Ê≥ïÂêå bind(to )
> 
> ‰∏ìÈó®ÈíàÂØπ‰∫éUIÁöÑÁâπÂÆöÂèØËßÇÂØüËÄÖÁ±ª
  
ÁâπÊÄß
  
> ÂÆÉ‰∏ç‰ºöÂèëÂ∞ÑÂá∫ÈîôËØØ(Error)‰∫ã‰ª∂

> ÂØπÂÆÉÁöÑËßÇÂØüËÆ¢ÈòÖÊòØÂèëÁîüÂú®‰∏ªÁ∫øÁ®ã(UIÁ∫øÁ®ã)ÁöÑ

> Ëá™Â∏¶shareReplayLatestWhileConnected 

```

/**
 Trait that represents observable sequence with following properties:

 - it never fails
 - it delivers events on `MainScheduler.instance`
 - `shareReplayLatestWhileConnected()` behavior
 - all observers share sequence computation resources
 - it's stateful, upon subscription (calling subscribe) last element is immediatelly replayed if it was produced
 - computation of elements is reference counted with respect to the number of observers
 - if there are no subscribers, it will release sequence computation resources

 `Driver<Element>` can be considered a builder pattern for observable sequences that drive the application.

 If observable sequence has produced at least one element, after new subscription is made last produced element will be
 immediately replayed on the same thread on which the subscription was made.

 When using `drive*`, `subscribe*` and `bind*` family of methods, they should always be called from main thread.

 If `drive*`, `subscribe*` and `bind*` are called from background thread, it is possible that initial replay
 will happen on background thread, and subsequent events will arrive on main thread.

 To find out more about traits and how to use them, please visit `Documentation/Traits.md`.
 */
public typealias Driver<E> = SharedSequence<DriverSharingStrategy, E>


```

```

  asDriver(onErrorJustReturn onErrorJustReturn: Self.E)

  asDriver(onErrorDriveWith onErrorDriveWith: RxCocoa.Driver<Self.E>)

  asDriver(onErrorRecover onErrorRecover: (error: ErrorType) -> RxCocoa.Driver<Self.E>)
  

```

* DisposeBag

> Á±ª‰ºº‰∫éObjective-C ARC‰∏≠ÁöÑËá™Âä®ÈáäÊîæÊ±†Êú∫Âà∂„ÄÇ
> 
> ÊñπÊ≥ïaddDisposableTo‰ºöÂØπDisposeBagËøõË°åÂº±ÂºïÁî®ÔºåÊâÄ‰ª•Ëøô‰∏™DisposeBagË¶ÅË¢´ÂÆû‰æãÂºïÁî®ÁùÄÔºå‰∏ÄËà¨ÂèØ‰Ωú‰∏∫ÂÆû‰æãÁöÑÊàêÂëòÂèòÈáèÔºåÂΩìÂÆû‰æãË¢´ÈîÄÊØÅ‰∫ÜÔºåÊàêÂëòDisposeBag‰ºöË∑üÁùÄÈîÄÊØÅÔºå‰ªéËÄå‰ΩøÂæóRxSwiftÂú®Ê≠§ÂÆû‰æã‰∏äÁªëÂÆöÁöÑËµÑÊ∫êÂæóÂà∞ÈáäÊîæ„ÄÇ


<!--### Ë°•ÂÖÖ: Objective-CÁöÑÊ∂àÊÅØ‰º†ÈÄí

[‰ªéÊ∫ê‰ª£Á†ÅÁúã ObjC ‰∏≠Ê∂àÊÅØÁöÑÂèëÈÄÅ](http://draveness.me/message.html)

[Ê∑±ÂÖ•Ëß£Êûê ObjC ‰∏≠ÊñπÊ≥ïÁöÑÁªìÊûÑ](http://draveness.me/method-struct.html)

#### Âü∫Êú¨Ê∂àÊÅØ‰º†ÈÄí

> Âú®Èù¢ÂêëÂØπË±°ÁºñÁ®ã‰∏≠ÔºåÂØπË±°Ë∞ÉÁî®ÊñπÊ≥ïÂè´ÂÅöÂèëÈÄÅÊ∂àÊÅØ„ÄÇ
> Âú®ÁºñËØëÊó∂ÔºåÁ®ãÂ∫èÁöÑÊ∫ê‰ª£Á†ÅÂ∞±‰ºö‰ªéÂØπË±°ÂèëÈÄÅÊ∂àÊÅØËΩ¨Êç¢ÊàêRuntimeÁöÑobjc_msgSendÂáΩÊï∞Ë∞ÉÁî®„ÄÇ
> ‰æãÂ¶ÇÊüêÂÆû‰æãÂèòÈáèreceiverÂÆûÁé∞Êüê‰∏Ä‰∏™ÊñπÊ≥ïoneMethod

```
[receiver oneMethod];

```
> Runtime‰ºöÂ∞ÜÂÖ∂ËΩ¨ÊàêÁ±ª‰ººËøôÊ†∑ÁöÑ‰ª£Á†Å

```
objc_msgSend(receiver, selector);

```

> ÂÖ∑‰ΩìÁöÑRuntime‰ºöÊ†πÊçÆÁ±ªÂûãËá™Âä®ËΩ¨Êç¢Êàê‰∏ãÂàóÊüê‰∏Ä‰∏™ÂáΩÊï∞Ôºö
> 
> objc_msgSend:ÊôÆÈÄöÁöÑÊ∂àÊÅØÈÉΩ‰ºöÈÄöËøáËØ•ÂáΩÊï∞ÂèëÈÄÅ
> 
> objc_msgSend_stret:Ê∂àÊÅØ‰∏≠ÊúâÊï∞ÊçÆÁªìÊûÑ‰Ωú‰∏∫ËøîÂõûÂÄºÔºà‰∏çÊòØÁÆÄÂçïÂÄºÔºâÊó∂ÔºåÈÄöËøáÊ≠§ÂáΩÊï∞ÂèëÈÄÅÂíåÊé•Êî∂ËøîÂõûÂÄº
> 
> objc_msgSendSuper:Âíåobjc_msgSendÁ±ª‰ººÔºåËøôÈáåÊääÊ∂àÊÅØÂèëÈÄÅÁªôÁà∂Á±ªÁöÑÂÆû‰æã
> 
> objc_msgSendSuper_stret:Âíåobjc_msgSend_stretÁ±ª‰ººÔºåËøôÈáåÊääÊ∂àÊÅØÂèëÈÄÅÁªôÁà∂Á±ªÁöÑÂÆû‰æãÂπ∂Êé•Êî∂ËøîÂõûÂÄº
> 

![message](https://www.ianisme.com/wp-content/uploads/2016/01/objective-runtime-2.png)

* objc_msgSendÂáΩÊï∞ÁöÑË∞ÉÁî®ËøáÁ®ãÔºö

> * Á¨¨‰∏ÄÊ≠•ÔºöÊ£ÄÊµãËøô‰∏™selectorÊòØ‰∏çÊòØË¶ÅÂøΩÁï•ÁöÑ„ÄÇ
> 
> * Á¨¨‰∫åÊ≠•ÔºöÊ£ÄÊµãËøô‰∏™targetÊòØ‰∏çÊòØnilÂØπË±°„ÄÇnilÂØπË±°ÂèëÈÄÅ‰ªª‰Ωï‰∏Ä‰∏™Ê∂àÊÅØÈÉΩ‰ºöË¢´ÂøΩÁï•Êéâ„ÄÇ
> * Á¨¨‰∏âÊ≠•Ôºö
> 		* 1.Ë∞ÉÁî®ÂÆû‰æãÊñπÊ≥ïÊó∂ÔºåÂÆÉ‰ºöÈ¶ñÂÖàÂú®Ëá™Ë∫´isaÊåáÈíàÊåáÂêëÁöÑÁ±ªÔºàclassÔºâmethodLists‰∏≠Êü•ÊâæËØ•ÊñπÊ≥ïÔºåÂ¶ÇÊûúÊâæ‰∏çÂà∞Âàô‰ºöÈÄöËøáclassÁöÑsuper_classÊåáÈíàÊâæÂà∞Áà∂Á±ªÁöÑÁ±ªÂØπË±°ÁªìÊûÑ‰ΩìÔºåÁÑ∂Âêé‰ªémethodLists‰∏≠Êü•ÊâæËØ•ÊñπÊ≥ïÔºåÂ¶ÇÊûú‰ªçÁÑ∂Êâæ‰∏çÂà∞ÔºåÂàôÁªßÁª≠ÈÄöËøásuper_classÂêë‰∏ä‰∏ÄÁ∫ßÁà∂Á±ªÁªìÊûÑ‰Ωì‰∏≠Êü•ÊâæÔºåÁõ¥Ëá≥Ê†πclassÔºõ
> 		* 2.ÂΩìÊàë‰ª¨Ë∞ÉÁî®Êüê‰∏™Êüê‰∏™Á±ªÊñπÊ≥ïÊó∂ÔºåÂÆÉ‰ºöÈ¶ñÂÖàÈÄöËøáËá™Â∑±ÁöÑisaÊåáÈíàÊâæÂà∞metaclassÔºåÂπ∂‰ªéÂÖ∂‰∏≠methodLists‰∏≠Êü•ÊâæËØ•Á±ªÊñπÊ≥ïÔºåÂ¶ÇÊûúÊâæ‰∏çÂà∞Âàô‰ºöÈÄöËøámetaclassÁöÑsuper_classÊåáÈíàÊâæÂà∞Áà∂Á±ªÁöÑmetaclassÂØπË±°ÁªìÊûÑ‰ΩìÔºåÁÑ∂Âêé‰ªémethodLists‰∏≠Êü•ÊâæËØ•ÊñπÊ≥ïÔºåÂ¶ÇÊûú‰ªçÁÑ∂Êâæ‰∏çÂà∞ÔºåÂàôÁªßÁª≠ÈÄöËøásuper_classÂêë‰∏ä‰∏ÄÁ∫ßÁà∂Á±ªÁªìÊûÑ‰Ωì‰∏≠Êü•ÊâæÔºåÁõ¥Ëá≥Ê†πmetaclassÔºõ
> * Á¨¨ÂõõÈÉ®ÔºöÂâç‰∏âÈÉ®ÈÉΩÊâæ‰∏çÂà∞Â∞±‰ºöËøõÂÖ•Âä®ÊÄÅÊñπÊ≥ïËß£Êûê

#### Ê∂àÊÅØÂä®ÊÄÅËß£Êûê

* Âä®ÊÄÅËß£ÊûêÊµÅÁ®ãÂõæ

![Âä®ÊÄÅËß£ÊûêÊµÅÁ®ãÂõæ](https://www.ianisme.com/wp-content/uploads/2016/01/objective-runtime-6.png)

> * Á¨¨‰∏ÄÊ≠•ÔºöÈÄöËøáresolveInstanceMethodÔºöÊñπÊ≥ïÂÜ≥ÂÆöÊòØÂê¶Âä®ÊÄÅÊ∑ªÂä†ÊñπÊ≥ï„ÄÇÂ¶ÇÊûúËøîÂõûYesÂàôÈÄöËøáclass_addMethodÂä®ÊÄÅÊ∑ªÂä†ÊñπÊ≥ïÔºåÊ∂àÊÅØÂæóÂà∞Â§ÑÁêÜÔºåÁªìÊùüÔºõÂ¶ÇÊûúËøîÂõûNoÔºåÂàôËøõÂÖ•‰∏ã‰∏ÄÊ≠•Ôºõ
> * Á¨¨‰∫åÊ≠•ÔºöËøôÊ≠•‰ºöËøõÂÖ•forwardingTargetForSelector:ÊñπÊ≥ïÔºåÁî®‰∫éÊåáÂÆöÂ§áÈÄâÂØπË±°ÂìçÂ∫îËøô‰∏™selectorÔºå‰∏çËÉΩÊåáÂÆö‰∏∫self„ÄÇÂ¶ÇÊûúËøîÂõûÊüê‰∏™ÂØπË±°Âàô‰ºöË∞ÉÁî®ÂØπË±°ÁöÑÊñπÊ≥ïÔºåÁªìÊùü„ÄÇÂ¶ÇÊûúËøîÂõûnilÔºåÂàôËøõÂÖ•Á¨¨‰∏âÈÉ®Ôºõ
> * Á¨¨‰∏âÈÉ®ÔºöËøôÊ≠•Êàë‰ª¨Ë¶ÅÈÄöËøámethodSignatureForSelector:ÊñπÊ≥ïÁ≠æÂêçÔºåÂ¶ÇÊûúËøîÂõûnilÔºåÂàôÊ∂àÊÅØÊó†Ê≥ïÂ§ÑÁêÜ„ÄÇÂ¶ÇÊûúËøîÂõûmethodSignatureÔºåÂàôËøõÂÖ•‰∏ã‰∏ÄÊ≠•Ôºõ
> * Á¨¨ÂõõÈÉ®ÔºöËøôÊ≠•Ë∞ÉÁî®forwardInvocationÔºöÊñπÊ≥ïÔºåÊàë‰ª¨ÂèØ‰ª•ÈÄöËøáanInvocationÂØπË±°ÂÅöÂæàÂ§öÂ§ÑÁêÜÔºåÊØîÂ¶Ç‰øÆÊîπÂÆûÁé∞ÊñπÊ≥ïÔºå‰øÆÊîπÂìçÂ∫îÂØπË±°Á≠âÔºåÂ¶ÇÊûúÊñπÊ≥ïË∞ÉÁî®ÊàêÂäüÔºåÂàôÁªìÊùü„ÄÇÂ¶ÇÊûúÂ§±Ë¥•ÔºåÂàôËøõÂÖ•doesNotRecognizeSelectorÊñπÊ≥ïÔºåËã•Êàë‰ª¨Ê≤°ÊúâÂÆûÁé∞Ëøô‰∏™ÊñπÊ≥ïÔºåÈÇ£‰πàÂ∞±‰ºöcrash„ÄÇ-->

### RxSwift ‰∏≠ÁöÑDelegateProxy

* proxy ÊµÅÁ®ãÂõæ

![‰ΩúÁî®ÊµÅÁ®ãÂõæ](./RxSwiftDelegateProxy.png)

* ÂÖ∑‰ΩìÂÖ≥Á≥ªÂèäÊñπÊ≥ïÂìçÂ∫î (UITableViewDelegate‰∏æ‰æã)


```
 	 let dataSource = RxTableViewSectionedReloadDataSource<SectionModel<String, Double>>()

    let delegate = RxTableViewSectionedReloadDelegate<SectionModel<String, Double>>()

    override func viewDidLoad() {
        super.viewDidLoad()
        
        let dataSource = self.dataSource
        let delegate = self.delegate
        
        let items = Observable.just([
            SectionModel(model: "First section", items: [
                1.0,
                2.0,
                3.0
                ]),
            SectionModel(model: "Second section", items: [
                1.0,
                2.0,
                3.0
                ]),
            SectionModel(model: "Third section", items: [
                1.0,
                2.0,
                3.0
                ])
            ])
        
        dataSource.configureCell = { (_, tv, indexPath, element) in
            let cell = tv.dequeueReusableCell(withIdentifier: "Cell")!
            cell.textLabel?.text = "\(element) @ row \(indexPath.row)"
            return cell
        }
        
        delegate.configureSection = { (_, tv, indexPath, element, type) in
            var identifier = "section"
            var sectionClass: AnyClass = FirstViewHeader.self
            if indexPath.section == 0 {
                tv.register(sectionClass, forHeaderFooterViewReuseIdentifier: identifier)
            }else if indexPath.section == 1 {
                identifier = "FirstSection"
                sectionClass = SecondViewHeader.self
                tv.register(sectionClass, forHeaderFooterViewReuseIdentifier: identifier)
            }else{
                identifier = "SecondSection"
                sectionClass = ThirdViewHeader.self
                tv.register(sectionClass, forHeaderFooterViewReuseIdentifier: identifier)
            }

            var v: RxTableViewSectionProxy
            if let view = tv.dequeueReusableHeaderFooterView(withIdentifier: identifier) as? RxTableViewSectionProxy {
                v = view
            }else {
                v = RxTableViewSectionProxy(reuseIdentifier: identifier)
            }
            v.textLabel?.text = "\(element)"
            v.contentView.backgroundColor = .randomColor
            print("react____\(v)")
            return v
        }
        
        delegate.sectionAndCellHeight = { (_, tv, indexPath, element, type) in
            var sectionClass: SimpleViewHeader.Type = FirstViewHeader.self
            if indexPath.section == 0 {
            }else if indexPath.section == 1 {
                sectionClass = SecondViewHeader.self
            }else{
                sectionClass = ThirdViewHeader.self
            }
            
            return sectionClass.heightForSection(withItem: element as AnyObject, indexPath: indexPath, sectionType: type)
        }
        delegate.cellHeight = { (_, tv, indexPath, element, type) in
            var sectionClass: SimpleViewHeader.Type = FirstViewHeader.self
            if indexPath.section == 0 {
            }else if indexPath.section == 1 {
                sectionClass = SecondViewHeader.self
            }else{
                sectionClass = ThirdViewHeader.self
            }
            
            return sectionClass.heightForSection(withItem: element as AnyObject, indexPath: indexPath, sectionType: type)
        }
        
        items
            .bind(to: tableView.rx.items(dataSource: dataSource))
            .disposed(by: disposeBag)
        
        items.bind(to: tableView.rx.sectionViews(delegate: delegate))
             .disposed(by: disposeBag)
        
        tableView.rx
            .itemSelected
            .map { indexPath in
                return (indexPath, dataSource[indexPath])
            }
            .subscribe(onNext: { indexPath, model in
                DefaultWireframe.presentAlert("Tapped `\(model)` @ \(indexPath)")
            })
            .disposed(by: disposeBag)
    }


```

---

### Delegate ÂàõÂª∫ Êï∞ÊçÆ‰∏édataSource ÁöÑÁªëÂÆö

* _TableViewSectionedDataSource ÁªßÊâøËá™ UITableViewDataSource, NSObject

```
// Â≠êÁ±ªÂ§çÂÜô
open func _rx_numberOfSections(in tableView: UITableView) -> Int {
        return 1
    }
    
// ‰ª£ÁêÜÊñπÊ≥ï
open func numberOfSections(in tableView: UITableView) -> Int {
    return _rx_numberOfSections(in: tableView)
}

```

* TableViewSectionedDataSource ÁªßÊâøËá™ _TableViewSectionedDataSource Â¢ûÂä†cell ÂàõÂª∫ÁöÑÈó≠ÂåÖ // Êâ©Â±ï, Â¢ûÂä†cellheight ÁöÑÈó≠ÂåÖ, sectionView ÁöÑÈó≠ÂåÖ & ÂàÜÂå∫È´òÂ∫¶ÁöÑÈó≠ÂåÖ

```
open override func _rx_tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
        precondition(indexPath.item < _sectionModels[indexPath.section].items.count)
        
        return configureCell(self, tableView, indexPath, self[indexPath])
    }

```

* RxTableViewSectionedReloadDataSource<S: SectionModelType> ÁªßÊâøËá™TableViewSectionedDatsSource & Protocol RxTableViewDataSourceType
* Ê†πÊçÆÂÆûÁé∞ÂçèËÆÆ RxTableViewDataSourceType Êù•ÁªëÂÆöÂ§ñÈÉ®Êï∞ÊçÆÊ∫ê

```

open func tableView(_ tableView: UITableView, observedEvent: Event<Element>) {
        UIBindingObserver(UIElement: self) { dataSource, element in
            #if DEBUG
                self._dataSourceBound = true
            #endif
            dataSource.setSections(element)
            
            tableView.reloadData()
        }.on(observedEvent)
    }
    
-------TableViewSectionedDataSource------

 open func setSections(_ sections: [S]) {
    self._sectionModels = sections.map { SectionModelSnapshot(model: $0, items: $0.items) }
}

```

### UITableView ‰∏éDelegate ÁªëÂÆö


* Ê†∏ÂøÉÁªëÂÆöÊñπÊ≥ï---> ObservableType ÁöÑÊâ©Â±ï

```
 func subscribeProxyDataSource<P: DelegateProxyType>(ofObject object: UIView, dataSource: AnyObject, retainDataSource: Bool, binding: @escaping (P, Event<E>) -> Void)
                -> Disposable {
                // ÂàõÂª∫ÊàñËÄÖÊü•ÊâæÂßîÊâò
                let proxy = P.proxyForObject(object)
                // ÂàõÂª∫‰ª£ÁêÜ&ÁªëÂÆöobject ‰ª£ÁêÜÊñπÊ≥ïÂìçÂ∫îÁöÑÂØπË±°
                let unregisterDelegate = P.installForwardDelegate(dataSource, retainDelegate: retainDataSource, onProxyForObject: object)
                // this is needed to flush any delayed old state (https://github.com/RxSwiftCommunity/RxDataSources/pull/75)
                object.layoutIfNeeded()

                let subscription = self.asObservable()
                    .observeOn(MainScheduler())
                    .catchError { error in
                        bindingErrorToInterface(error)
                        return Observable.empty()
                    }
                    // source can never end, otherwise it would release the subscriber, and deallocate the data source
                    .concat(Observable.never())
                    .takeUntil(object.rx.deallocated)
                    .subscribe { [weak object] (event: Event<E>) in
                        if let object = object {
                            assert(proxy === P.currentDelegateFor(object), "Proxy changed from the time it was first set.\nOriginal: \(proxy)\nExisting: \(String(describing: P.currentDelegateFor(object)))")
                        }
                        
                        // ÈÄöËøáËØ•Âè•ÂÆûÁé∞Êï∞ÊçÆÊ∫êÊï∞ÊçÆÁöÑ‰º†ÈÄí, event Êê∫Â∏¶Êï∞ÊçÆ
                        binding(proxy, event)
                        
                        switch event {
                        case .error(let error):
                            bindingErrorToInterface(error)
                            unregisterDelegate.dispose()
                        case .completed:
                            unregisterDelegate.dispose()
                        default:
                            break
                        }
                    }
                    
                return Disposables.create { [weak object] in
                    subscription.dispose()
                    object?.layoutIfNeeded()
                    unregisterDelegate.dispose()
                }
            }
```

**binding Èó≠ÂåÖÁöÑÂÆûÁé∞**

```
 guard let tableView = tableView else {
                        return
                    }
                    
delegate.tableView(tableView, observedEvent: event)

```

* P.proxyForObject(object)

```
    public static func proxyForObject(_ object: AnyObject) -> Self {
		MainScheduler.ensureExecutingOnScheduler()

        let maybeProxy = Self.assignedProxyFor(object) as? Self

        let proxy: Self
        if let existingProxy = maybeProxy {
            proxy = existingProxy
        }
        else {
            proxy = Self.createProxyForObject(object) as! Self
            Self.assignProxy(proxy, toObject: object)
        }
        
        let currentDelegate: AnyObject? = Self.currentDelegateFor(object)
        if currentDelegate !== proxy {
            proxy.setForwardToDelegate(currentDelegate, retainDelegate: false)
            Self.setCurrentDelegate(proxy, toObject: object)
        }

        return proxy
       }
```

* ‰ªîÁªÜÂàÜÊûê let unregisterDelegate = P.installForwardDelegate(dataSource, retainDelegate: retainDataSource, onProxyForObject: object)

```

 public static func installForwardDelegate(_ forwardDelegate: AnyObject, retainDelegate: Bool, onProxyForObject object: AnyObject) -> Disposable {

        .........proxy.forwardToDelegate()‰∏∫Á©∫Ê†°È™å.........

        proxy.setForwardToDelegate(forwardDelegate, retainDelegate: retainDelegate)
        
        .........Ê†πÊçÆruntimeÂä®ÊÄÅÊñπÊ≥ïÂìçÂ∫îÂÆûÁé∞ÁªëÂÆö.........

```

*  proxy.setForwardToDelegate(forwardDelegate, retainDelegate: retainDelegate) ÁöÑobjc ÂÆûÁé∞

```
open func setForwardToDelegate(_ delegate: AnyObject?, retainDelegate: Bool) {
        #if DEBUG // 4.0 all configurations
            MainScheduler.ensureExecutingOnScheduler()
        #endif
        self._setForward(toDelegate: delegate, retainDelegate: retainDelegate)
        self.reset()
    }
    
internal func reset() {
    guard let delegateProxySelf = self as? DelegateProxyType else {
        rxFatalErrorInDebug("\(self) doesn't implement delegate proxy type.")
        return
    }
    
    guard let parentObject = self.parentObject else { return }

    let selfType = type(of: delegateProxySelf)

    let maybeCurrentDelegate = selfType.currentDelegateFor(parentObject)

    if maybeCurrentDelegate === self {
        selfType.setCurrentDelegate(nil, toObject: parentObject)
        selfType.setCurrentDelegate(self, toObject: parentObject)
    }
}

```

```
UITableViewDataSource ÁöÑÈáçÂÜô Â∞Üdata È©±Âä®ÁöÑdataSource ‰∏étableViewÂÖ≥ËÅî
    public class func setCurrentDelegate(_ delegate: AnyObject?, toObject object: AnyObject) {
        let tableView: UITableView = castOrFatalError(object)
        tableView.dataSource = castOptionalOrFatalError(delegate)
    }

```

```

-(id)_forwardToDelegate {
    return __forwardToDelegate;
}

-(void)_setForwardToDelegate:(id __nullable)forwardToDelegate retainDelegate:(BOOL)retainDelegate {
    __forwardToDelegate = forwardToDelegate;
    
    if (retainDelegate) {
        self.strongForwardDelegate = forwardToDelegate;
    }
    else {
        self.strongForwardDelegate = nil;
    }
}

```


* ÈÄöËøáÂØπUIKit Â¢ûÂä†Êâ©Â±ïÊù•ËøîÂõû RxDelegateProxy ÁöÑÂÆû‰æãÂØπË±°

```

extension UITableView {
 
    /**
    Factory method that enables subclasses to implement their own `delegate`.
    
    - returns: Instance of delegate proxy that wraps `delegate`.
    */
    public override func createRxDelegateProxy() -> RxTableViewDelegateProxy {
        return RxTableViewDelegateProxy(parentObject: self)
    }

    /**
    Factory method that enables subclasses to implement their own `rx.dataSource`.
    
    - returns: Instance of delegate proxy that wraps `dataSource`.
    */
    public func createRxDataSourceProxy() -> RxTableViewDataSourceProxy {
        return RxTableViewDataSourceProxy(parentObject: self)
    }

}

```